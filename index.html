<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Free-Form Merge</title>
    <style>
        :root {
            --bg-color: #bbada0;
            --grid-color: #cdc1b4;
            --tile-base-size: 80px;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            margin: 0;
            height: 100vh;
            width: 100vw;
            overflow: hidden; /* Canvas style */
            user-select: none;
            position: relative;
        }

        h1 {
            position: absolute;
            top: 10px;
            left: 20px;
            color: #eee4da;
            margin: 0;
            z-index: 0;
            pointer-events: none;
        }

        .instructions {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(238, 228, 218, 0.9);
            padding: 15px;
            border-radius: 5px;
            max-width: 300px;
            font-size: 14px;
            z-index: 1000;
            pointer-events: auto;
        }

        /* The Game Area */
        #game-canvas {
            width: 100%;
            height: 100%;
            position: relative;
        }

        /* Spawn Points Visuals (Optional background grid) */
        .spawn-grid {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: grid;
            grid-template-columns: repeat(5, 100px); /* 5x5 */
            grid-template-rows: repeat(5, 100px);
            gap: 20px;
            pointer-events: none; /* Just visual */
            z-index: 0;
        }

        .spawn-point {
            background-color: rgba(205, 193, 180, 0.5);
            border-radius: 6px;
            width: 100%;
            height: 100%;
        }

        /* TILES */
        .tile {
            position: absolute;
            min-width: var(--tile-base-size);
            min-height: var(--tile-base-size);
            border-radius: 4px;
            display: inline-flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            font-size: 24px;
            cursor: grab;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            transition: transform 0.1s ease, background-color 0.2s;
            box-sizing: border-box;
            z-index: 10;
        }

        .tile:active {
            cursor: grabbing;
        }

        .tile.dragging {
            z-index: 1000 !important;
            box-shadow: 0 15px 30px rgba(0,0,0,0.4);
            transform: scale(1.1);
            opacity: 0.7; /* Transparency as requested */
            transition: none;
        }

        /* Pure Numbers */
        .tile[data-val="1"] { background-color: #eee4da; color: #776e65; }
        .tile[data-val="3"] { background-color: #ede0c8; color: #776e65; }
        .tile[data-val="4"] { background-color: #f2b179; color: #f9f6f2; }
        .tile[data-val="7"] { background-color: #f59563; color: #f9f6f2; }
        .tile[data-val="14"] { background-color: #f67c5f; color: #f9f6f2; }
        .tile[data-val="28"] { background-color: #f65e3b; color: #f9f6f2; }

        /* Container Styles */
        .tile.container {
            background-color: #3e3933;
            border: 3px solid #8f7a66;
            padding: 15px;
            display: flex; /* Ensure flex behavior */
            flex-wrap: wrap;
            align-content: center;
            justify-content: center;
            gap: 8px; /* Gap between items */
            
            /* Auto sizing based on content, but min size */
            width: auto; 
            height: auto;
            min-width: 140px;
            min-height: 140px;
            max-width: none; /* Allow infinite growth */
            z-index: 5;
            transition: width 0.2s ease, height 0.2s ease; /* Smooth growth */
        }

        /* Nested Items Generic */
        .tile .tile {
            position: relative; /* Flow inside container */
            margin: 0; /* Handled by gap */
            transform: scale(1);
            z-index: 10;
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
            transition: transform 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275); /* Bouncy transition */
        }

        /* Nested PURE items */
        .tile .tile.pure {
            width: 60px; 
            height: 60px;
            font-size: 20px;
        }

        /* Nested CONTAINER items */
        .tile .tile.container {
            width: auto;
            height: auto;
            min-width: 120px;
            min-height: 120px;
            background-color: #2f2b26; 
            border: 2px solid #776e65;
            padding: 10px;
        }
        
        /* HOVER / TARGET ANIMATIONS */
        @keyframes targetPulse {
            0% { transform: scale(1.05); box-shadow: 0 0 10px 4px rgba(255, 215, 0, 0.6); }
            50% { transform: scale(1.12); box-shadow: 0 0 20px 8px rgba(255, 215, 0, 0.8); border-color: gold;}
            100% { transform: scale(1.05); box-shadow: 0 0 10px 4px rgba(255, 215, 0, 0.6); }
        }

        .hover-target {
            animation: targetPulse 1.5s infinite ease-in-out;
            z-index: 50 !important;
            border-color: gold !important;
            box-shadow: 0 0 15px gold;
        }

        /* OVERSEER TERMINAL */
        #overseer-ui {
            position: fixed;
            top: 10px;
            right: 10px;
            width: 300px;
            background: rgba(0, 0, 0, 0.85);
            border: 1px solid #0f0;
            color: #0f0;
            font-family: 'Courier New', Courier, monospace;
            padding: 10px;
            z-index: 2000;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.2);
            font-size: 14px;
            pointer-events: none; /* Let clicks pass through */
            display: none; /* Hidden until boot */
            transition: opacity 0.3s ease-in-out;
        }
        
        .scan-line {
            width: 100%;
            height: 100px;
            z-index: 2001;
            background: linear-gradient(0deg, rgba(0,0,0,0) 0%, rgba(0, 255, 0, 0.1) 50%, rgba(0,0,0,0) 100%);
            opacity: 0.1;
            position: absolute;
            bottom: 100%;
            animation: scanline 10s linear infinite;
            pointer-events: none; /* FLIX: Don't block mouse clicks */
        }

        @keyframes scanline {
            0% { bottom: 100%; }
            100% { bottom: -100%; }
        }

        #overseer-preview {
            margin-top: 10px;
            border: 1px dashed #0f0;
            padding: 10px;
            min-height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0, 20, 0, 0.5);
        }
        
        #overseer-preview .tile {
            position: relative !important; /* Override absolute for preview */
            left: auto !important;
            top: auto !important;
            transform: scale(0.9); /* Miniaturize */
            box-shadow: 0 0 5px #0f0;
        }
        
        @keyframes shake {
            10%, 90% { transform: translate3d(-1px, 0, 0); }
            20%, 80% { transform: translate3d(2px, 0, 0); }
            30%, 50%, 70% { transform: translate3d(-4px, 0, 0); }
            40%, 60% { transform: translate3d(4px, 0, 0); }
        }

    </style>
</head>
<body>

    <div id="overseer-ui">
        <div class="scan-line"></div>
        <div id="overseer-header">>> SYSTEM.OVR // ONLINE</div>
        <hr style="border-color: #0f0; opacity: 0.3; margin: 5px 0;">
        <div id="overseer-log">Initializing...</div>
        <div id="overseer-quest" style="margin-top: 10px; color: #fff; font-weight: bold;"></div>
        <div id="overseer-preview"></div>
    </div>

    <h1>Free-Form Merge</h1>
    
    <div id="game-canvas">
        <div class="spawn-grid" id="spawn-grid">
            <!-- 5x5 Grid generated JS -->
        </div>
        <!-- Tiles appended here -->
    </div>

    <div class="instructions">
        <strong>Regeln:</strong><br>
        - Frei bewegen.<br>
        - Aufeinander werfen zum Mergen.<br>
        - <strong>1+1 -> [1,1]</strong><br>
        - <strong>[1,1]+1 -> 3</strong><br>
        - <strong>3+4 -> 7</strong><br>
        - Container wachsen automatisch.<br>
    </div>

<script>
    // -- CONFIG --
    const SPAWN_ROWS = 5;
    const SPAWN_COLS = 5;
    const TILE_SIZE = 80;
    const GAP = 20;
    const MAX_DEPTH = 2; // Maximum visual nesting depth

    // -- STATE --
    let tiles = []; // List of Root Tile Objects
    let nextId = 1;
    
    // -- DOM --
    const canvas = document.getElementById('game-canvas');
    const spawnGrid = document.getElementById('spawn-grid');

    // -- INIT --
    function init() {
        // Generate Spawn Grid Background
        spawnGrid.innerHTML = '';
        const startX = (window.innerWidth - (SPAWN_COLS * 100 + (SPAWN_COLS-1)*20)) / 2; // Approx centering
        
        for(let i=0; i<SPAWN_ROWS * SPAWN_COLS; i++) {
            let div = document.createElement('div');
            div.className = 'spawn-point';
            spawnGrid.appendChild(div);
        }

        // Spawn Starters
        spawnTile(1);
        spawnTile(1);
        spawnTile(1);
        spawnTile(1);
    }

    // -- DATA MODEL --
    class TileData {
        constructor(type, valOrParts, x, y) {
            this.id = nextId++;
            this.type = type; // 'pure', 'container'
            this.x = x || 100;
            this.y = y || 100;
            this.vx = 0;
            this.vy = 0;
            
            if (type === 'pure') {
                this.value = valOrParts;
                this.parts = [];
            } else {
                this.value = null;
                this.parts = valOrParts;
            }
        }
    }

    // -- LOGIC --

    function spawnTile(val) {
        // SAFE ZONE: Avoid Top Right (Overseer UI)
        // x > window.innerWidth - 350 && y < 400
        
        let safe = false;
        let attempts = 0;
        let x, y;
        
        while(!safe && attempts < 50) {
            // Strategy 1: Random (Fallback)
            x = 50 + Math.random() * (window.innerWidth - 200);
            y = 50 + Math.random() * (window.innerHeight - 200);
            
            // Check Safe Zone
            if (y < 400 && x > (window.innerWidth - 350)) {
                safe = false;
            } else {
                safe = true;
            }
            attempts++;
        }
        
        // If we still aren't safe, default to Top Left
        if (!safe) { x = 100; y = 100; }

        const tile = new TileData('pure', val, x, y);
        tiles.push(tile);
        renderTile(tile);
    }

    // [Redundant renderTile removed to use the main one with effects]

    function findParentOf(id, list) {
        for (let t of list) {
            if (t.type === 'container') {
                let idx = t.parts.findIndex(p => p.id === id);
                if (idx !== -1) return { parent: t, index: idx };
                let deep = findParentOf(id, t.parts);
                if (deep) return deep;
            }
        }
        return null;
    }

    // -- INTERACTION (MOUSE DRAG) --

    let dragItem = null; // { tileData, domEl, offsetX, offsetY, originalParent, originalIndex }
    let isDragging = false;
    let dragClone = null; // Visual clone if dragging out of container?
    // Actually: If dragging from container, we remove it from container and make it a root tile immediately?
    // Or we drag a ghost?
    // User expectation: "steal" the item.
    // Plan: On MouseDown on a nested item, remove it from data, promote to root tile at that position, start dragging it.

    document.addEventListener('mousedown', handleMouseDown);
    document.addEventListener('mousemove', handleMouseMove);
    document.addEventListener('mouseup', handleMouseUp);

    function handleMouseDown(e) {
        let el = e.target.closest('.tile');
        if (!el) return;
        
        e.preventDefault(); 

        let id = parseInt(el.dataset.id);
        let root = tiles.find(t => t.id === id);
        
        if (root) {
            startDrag(root, el, e.clientX, e.clientY);
        } else {
            // Nested Item Drag
            let parentInfo = findParentOf(id, tiles);
            if (parentInfo) {
                // 1. CAPTURE COORDINATES *BEFORE* MODIFYING DOM
                let rect = el.getBoundingClientRect();
                let canvasRect = canvas.getBoundingClientRect();

                let item = parentInfo.item;
                parentInfo.parent.parts.splice(parentInfo.index, 1);
                
                // Cleanup Parent
                // STRICT MODE: When dragging OUT, do not auto-combine remaining junk.
                simplifyContainer(parentInfo.parent, false);
                
                if (tiles.includes(parentInfo.parent) && parentInfo.parent.parts.length === 0 && parentInfo.parent.type === 'container') {
                    tiles = tiles.filter(t => t !== parentInfo.parent);
                    let parentEl = document.querySelector(`.tile[data-id="${parentInfo.parent.id}"]`);
                    if(parentEl) parentEl.remove();
                } else {
                    let parentEl = document.querySelector(`.tile[data-id="${parentInfo.parent.id}"]`);
                    if (parentEl) updateTileVisuals(parentEl, parentInfo.parent);
                }

                // Promote to Root
                // Use captured rects
                item.x = rect.left - canvasRect.left;
                item.y = rect.top - canvasRect.top;
                tiles.push(item);
                
                let newEl = renderTile(item);
                startDrag(item, newEl, e.clientX, e.clientY);
            }
        }
    }

    function startDrag(tileObj, domEl, mx, my) {
        isDragging = true;
         // Calculate offset relative to TILE position (which is canvas relative)
         // mx is screen, tileObj.x is canvas relative.
         // We need offset = (ScreenMouse - CanvasScreenPos) - TileX
         // Simplification:
         // style.left = MouseScreenX - offsetX.
         // We want style.left = tileObj.x.
         // so offsetX = MouseScreenX - tileObj.x
         // Wait, checking `handleMouseMove`: x = e.clientX - offsetX.
         // if offsetX = mx - tileObj.x
         // left = mx_new - (mx_start - start_x).
         // left = start_x + (mx_new - mx_start).
         // This assumes start_x is correct screen coord? NO.
         
         // If tileObj.x is CANVAS RELATIVE.
         // And Mouse is SCREEN relative.
         
         // We need to normalize Mouse to Canvas too? 
         // Or just treat offset as a delta?
         
         // Let's rely on map: 
         // offsetX should be the dist from Mouse to Element TopLeft.
         // In Rendered DOM, element left is relative to canvas.
         // Screen Rect Left = CanvasRect.left + style.left.
         // Mouse is at mx.
         // offsetX = mx - (CanvasRect.left + style.left).
         
         let canvasRect = canvas.getBoundingClientRect();
         let tileScreenLeft = canvasRect.left + tileObj.x;
         let tileScreenTop = canvasRect.top + tileObj.y;
         
         dragItem = {
            tile: tileObj,
            el: domEl,
            // This assumes 'mx' is comparible to 'x'. It is NOT if x is relative!
            // Correct way for relative drag:
            // We want to calculate new x/y. 
            // x = (Mouse - CanvasLeft) - (MouseInsideTileOffset)
            
            // Re-calc mouse offset inside tile
            mouseInsideX: mx - tileScreenLeft,
            mouseInsideY: my - tileScreenTop
        };
        
        domEl.classList.add('dragging');
        domEl.style.zIndex = 999;
    }

    function handleMouseMove(e) {
        if (!isDragging || !dragItem) return;

        // Calc new Canvas Relative pos
        let canvasRect = canvas.getBoundingClientRect();
        let relX = e.clientX - canvasRect.left;
        let relY = e.clientY - canvasRect.top;
        
        let x = relX - dragItem.mouseInsideX;
        let y = relY - dragItem.mouseInsideY;
        
        // Update Model
        dragItem.tile.x = x;
        dragItem.tile.y = y;
        
        // Update Visual
        dragItem.el.style.left = x + 'px';
        dragItem.el.style.top = y + 'px';

        // Hit Test Visuals
        dragItem.el.style.display = 'none';
        let elBelow = document.elementFromPoint(e.clientX, e.clientY);
        dragItem.el.style.display = '';

        document.querySelectorAll('.hover-target').forEach(el => el.classList.remove('hover-target'));

        if (elBelow) {
            let targetTileEl = elBelow.closest('.tile');
            if (targetTileEl && targetTileEl !== dragItem.el) {
                targetTileEl.classList.add('hover-target');
            }
        }
    }

    function handleMouseUp(e) {
        if (!isDragging || !dragItem) return;

        isDragging = false;
        dragItem.el.classList.remove('dragging');
        dragItem.el.style.zIndex = '';
        document.querySelectorAll('.hover-target').forEach(el => el.classList.remove('hover-target'));

        // Use Mouse Position for Merge Check
        checkMerge(dragItem.tile, dragItem.el, e.clientX, e.clientY);
        
        dragItem = null;
    }

    function checkMerge(sourceTile, sourceEl, mx, my) {
        // Find overlap using Mouse Position (most intuitive for "Aiming")
        
        sourceEl.style.display = 'none';
        let elementBelow = document.elementFromPoint(mx, my);
        sourceEl.style.display = '';

        if (!elementBelow) return false;

        let targetEl = elementBelow.closest('.tile');
        
        // Ensure we didn't hit ourself (handled by display:none)
        // Ensure we hit a valid tile
        if (targetEl) {
             let tid = parseInt(targetEl.dataset.id);
             // Verify it is NOT the source tile (just in case)
             if (tid !== sourceTile.id) {
                 // We hit a DOM Element .tile. 
                 // It could be a Root or a Nested Tile.
                 // We need to find the ROOT that owns this element to pass to performMerge
                 // performMerge logic expects the Root Target, and then re-finds the specific sub-element.
                 // Let's optimize: performMerge can take the specific element we hit.
                 
                 // Find Root of targetEl
                 // We can traverse up DOM or lookup in `tiles`.
                 // Note: nested tiles don't have IDs in `tiles` array, only Roots do.
                 // But wait, `renderTile` assigns data-id to all tiles.
                 // So we can find the root by traversing up DOM until we find one in `tiles`.
                 
                 let ptr = targetEl;
                 let rootTileData = null;
                 
                 while(ptr && !rootTileData) {
                     if (ptr.classList.contains('tile')) {
                         let id = parseInt(ptr.dataset.id);
                         rootTileData = tiles.find(t => t.id === id);
                     }
                     if (!rootTileData) ptr = ptr.parentElement;
                 }

                 if (rootTileData) {
                     performMerge(rootTileData, targetEl, sourceTile, sourceEl, mx, my);
                 }
             }
        }
    }

    function performMerge(rootTargetTile, hitEl, sourceTile, sourceEl, sx, sy) {
        // hitEl is the specific DOM element we aimed at. 
        // It belongs to rootTargetTile structure.
        
        // Identify Data for hitEl
        // Since we have the ID on all tiles...
        let hitId = parseInt(hitEl.dataset.id);
        
        // Case 1: We hit the Root Tile Background
        // Case 2: We hit a Sub Item
        
        let droppedOnItem = false;
        let subItemData = null;
        let parentOfSub = null;
        let indexInParent = -1;

        if (hitId === rootTargetTile.id) {
            // Hit Root
            // But Root can be a Container or Pure.
            // If Root is Pure, it's effectively an Item.
            // If Root is Container, we hit its background?
            // User intention: Dropping on Container Background -> Add to List.
            // Dropping on Pure Root -> Merge with it (Group).
            
            if (rootTargetTile.type === 'pure') {
                droppedOnItem = true;
                subItemData = rootTargetTile;
                // It has no parent (it is root)
                // We handle Root grouping specially
            }
        } else {
             // Hit Nested Item
             let info = findParentOf(hitId, [rootTargetTile]);
             if (info) {
                 droppedOnItem = true;
                 subItemData = info.item;
                 parentOfSub = info.parent;
                 indexInParent = info.index;
             }
        }

        // REMOVE Source from Root List
        tiles = tiles.filter(t => t.id !== sourceTile.id);
        
        // SPAWN PARTICLES
        let rect = sourceEl.getBoundingClientRect();
        let canvasRect = canvas.getBoundingClientRect();
        let px = rect.left - canvasRect.left + rect.width/2;
        let py = rect.top - canvasRect.top + rect.height/2;
        spawnExplosion(px, py, '#f65e3b'); // Default color, ideally from tile
        
        // TRIGGER SHAKE
        triggerScreenShake();

        sourceEl.remove();

        // MERGE
        if (droppedOnItem) {
            // Explicit Item Merge -> Always Simplify specific group
            if (subItemData.type === 'container') {
                subItemData.parts.push(sourceTile);
                simplifyContainer(subItemData, true); // Force check
            } else {
                // subItemData is Pure.
                // Create Group [subItem, source].
                
                // If subItem was Root Pure, we convert Root to Container.
                // If subItem was Nested Pure, we wrap it? Or check depth.
                
                let targetIsRoot = (subItemData === rootTargetTile);
                
                // Depth check (only for nested creation)
                let depth = targetIsRoot ? 0 : getDepth(rootTargetTile, parentOfSub);
                
                if (depth >= MAX_DEPTH) {
                    // Flatten Fallback: Add to parent (if not root pure?)
                    // If root pure, we MUST create container (depth 0, allowed).
                    if (targetIsRoot) {
                        // Should be allowed
                        let oldVal = rootTargetTile.value;
                        rootTargetTile.type = 'container';
                        rootTargetTile.value = null;
                        rootTargetTile.parts = [new TileData('pure', oldVal, 0,0), sourceTile];
                        simplifyContainer(rootTargetTile, true);
                    } else {
                        // Add to parent container instead of wrapping
                        parentOfSub.parts.push(sourceTile);
                        // Add to parent, no simplify? 
                        // User intended to merge item.
                        // Can we check if parent now matches recipe FULLY?
                        simplifyContainer(parentOfSub, false); 
                    }
                } else {
                    // Allowed to Wrap
                    if (targetIsRoot) {
                         // Convert Root
                         let oldVal = rootTargetTile.value;
                         let p1 = new TileData('pure', oldVal, 0,0);
                         rootTargetTile.type = 'container';
                         rootTargetTile.value = null;
                         rootTargetTile.parts = [p1, sourceTile];
                         simplifyContainer(rootTargetTile, true);
                    } else {
                        // Wrap Nested
                        let newGroup = new TileData('container', [subItemData, sourceTile], 0, 0); 
                        simplifyContainer(newGroup, true);
                        parentOfSub.parts[indexInParent] = newGroup;
                    }
                }
            }
            
        } else {
            // Dropped on Root Container Background
            // Just Add.
            rootTargetTile.parts.push(sourceTile);
            // Only auto-simplify if FULL MATCH (Hybrid)
            simplifyContainer(rootTargetTile, false);
        }

        updateTileVisuals(document.querySelector(`.tile[data-id="${rootTargetTile.id}"]`), rootTargetTile);
        spawnTileIfNeeded();
    }

    // -- HELPERS --

    function findParentOf(id, list) {
        for(let tile of list) {
            if (tile.type === 'container') {
                // Direct child?
                let idx = tile.parts.findIndex(p => p.id === id);
                if (idx !== -1) return { parent: tile, index: idx, item: tile.parts[idx] };
                
                // Deep search
                let found = findParentOf(id, tile.parts);
                if (found) return found;
            }
        }
        return null; // Not found
    }

    function getDepth(root, targetNode) {
        if (root === targetNode) return 0;
        if (root.type !== 'container') return -1;
        
        for(let p of root.parts) {
            let d = getDepth(p, targetNode);
            if (d !== -1) return d + 1;
        }
        return -1;
    }

    // -- RECIPES --
    // 'force' = Standard behavior (matches subsets)
    // 'strict' (false) = Only matches if container is perfectly consumed
    function simplifyContainer(tile, force = true) {
        if (tile.type === 'pure') return;

        // 1. Recursive Simplify Children always
        tile.parts.forEach(p => simplifyContainer(p, force));

        // 2. Simplify this level
        let changed = true;
        while(changed) {
            changed = false;
            
            let pures = tile.parts.filter(p => p.type === 'pure');
            
            // Check Recipes
            // We collect candidates
            let recipeMatch = null;

            // 7+7
            let doubles = {};
            pures.forEach(p => { if (p.value >= 7) doubles[p.value] = (doubles[p.value] || 0) + 1; });
            for(let val in doubles) {
                if (doubles[val] >= 2) {
                    // This is a match
                    if (force || tile.parts.length === 2) {
                        let v = parseInt(val);
                        removeByVal(tile, v);
                        removeByVal(tile, v);
                        tile.parts.push(new TileData('pure', v * 2, 0,0));
                        changed = true;
                    }
                }
            }
            if(changed) continue;

            // 4+3
            if (hasVal(tile, 4) && hasVal(tile, 3)) {
                if (force || tile.parts.length === 2) {
                    removeByVal(tile, 4);
                    removeByVal(tile, 3);
                    tile.parts.push(new TileData('pure', 7, 0,0));
                    changed = true;
                    continue;
                }
            }

            // 3+1
            if (hasVal(tile, 3) && hasVal(tile, 1)) {
                if (force || tile.parts.length === 2) {
                    removeByVal(tile, 3);
                    removeByVal(tile, 1);
                    tile.parts.push(new TileData('pure', 4, 0,0));
                    changed = true;
                    continue;
                }
            }
            
            // 1+1+1 -> 3
            let ones = pures.filter(p => p.value === 1);
            if (ones.length >= 3) {
                if (force || tile.parts.length === 3) {
                    removeByVal(tile, 1);
                    removeByVal(tile, 1);
                    removeByVal(tile, 1);
                    tile.parts.push(new TileData('pure', 3, 0,0));
                    changed = true;
                    continue; 
                }
            }
        }

        // 3. FLATTEN CHECK (Always safe)
        if (tile.parts.length === 1 && tile.parts[0].type === 'pure') {
            let survivor = tile.parts[0];
            tile.type = 'pure';
            tile.value = survivor.value;
            tile.parts = [];
        }
    }

    function hasVal(tile, val) {
        return tile.parts.some(p => p.type === 'pure' && p.value === val);
    }

    function removeByVal(tile, val) {
        let idx = tile.parts.findIndex(p => p.type === 'pure' && p.value === val);
        if (idx !== -1) tile.parts.splice(idx, 1);
    }
    
    function createGrid() {
        // Clear logic but keep visual grid for reference
        let gridEl = document.getElementById('spawn-grid');
        gridEl.innerHTML = '';
        // 5x5 Grid for visuals
        for (let i = 0; i < 25; i++) {
            let cell = document.createElement('div');
            cell.className = 'grid-cell';
            gridEl.appendChild(cell);
        }
    }
    
    // -- PHYSICS ENGINE --
    let lastMouseX = 0, lastMouseY = 0;
    let mouseVX = 0, mouseVY = 0;

    function init() {
        // Create Grid
        createGrid();
        
        // Spawn Initial Tiles
        spawnTile(1);
        spawnTile(1);
        spawnTile(1);

        // Start Loops
        requestAnimationFrame(updatePhysics);
    }

    // -- PARTICLE SYSTEM --
    let particles = [];

    function spawnExplosion(x, y, color) {
        for (let i = 0; i < 20; i++) {
            particles.push({
                x: x,
                y: y,
                vx: (Math.random() - 0.5) * 10,
                vy: (Math.random() - 0.5) * 10,
                life: 1.0,
                color: color || '#gold'
            });
        }
    }

    function updateParticles() {
        if (particles.length === 0) return;

        for (let i = particles.length - 1; i >= 0; i--) {
            let p = particles[i];
            p.x += p.vx;
            p.y += p.vy;
            p.life -= 0.03; // Fade out

            // Retrieve or Create DOM element? 
            // For performance spawning 20 DOM elements per merge might be heavy.
            // Let's use a simple overlay div or just manage a pool?
            // actually, for this "Overengineered" vibe, let's just create them and remove them.
            // Optimization: Maybe just draw them? No, we stuck to DOM.
            // Let's use a container for particles.
            
            if (!p.el) {
                p.el = document.createElement('div');
                p.el.style.position = 'absolute';
                p.el.style.width = '6px';
                p.el.style.height = '6px';
                p.el.style.borderRadius = '50%';
                p.el.style.backgroundColor = p.color;
                p.el.style.pointerEvents = 'none';
                p.el.style.zIndex = '9999';
                canvas.appendChild(p.el);
            }

            p.el.style.left = p.x + 'px';
            p.el.style.top = p.y + 'px';
            p.el.style.opacity = p.life;
            p.el.style.transform = `scale(${p.life})`;

            if (p.life <= 0) {
                p.el.remove();
                particles.splice(i, 1);
            }
        }
    }

    function updatePhysics() {
        // ... (existing physics code) ...
        updateParticles(); // Add this line

        // Friction factor
        const friction = 0.92;
        const stopThreshold = 0.1;

        tiles.forEach(tile => {
            // Only physics for Root tiles that are NOT being dragged
            // Nested tiles move with parent. Dragged tiles move with mouse.
            if ((!dragItem || dragItem.tile !== tile) && (Math.abs(tile.vx) > stopThreshold || Math.abs(tile.vy) > stopThreshold)) {
                
                // Apply Velocity
                tile.x += tile.vx;
                tile.y += tile.vy;

                // Apply Friction
                tile.vx *= friction;
                tile.vy *= friction;

                // Wall Bounce (Canvas Boundaries)
                // Assume canvas currently expands? Or fixed? 
                // Let's assume window-ish bounds or just ensure positive for now
                // Ideally we get canvas size
                let maxX = canvas.clientWidth - 80; // approximate tile width
                let maxY = canvas.clientHeight - 80;

                if (tile.x < 0) { tile.x = 0; tile.vx = -tile.vx * 0.7; }
                if (tile.y < 0) { tile.y = 0; tile.vy = -tile.vy * 0.7; }
                // Optional: Max bounds if we want to contain them
                 if (tile.x > maxX && maxX > 0) { tile.x = maxX; tile.vx = -tile.vx * 0.7; }
                 if (tile.y > maxY && maxY > 0) { tile.y = maxY; tile.vy = -tile.vy * 0.7; }

                // Update DOM
                let el = document.querySelector(`.tile[data-id="${tile.id}"]`);
                if (el) {
                    el.style.left = tile.x + 'px';
                    el.style.top = tile.y + 'px';
                }
            } else {
                // Zero out if very slow
                 if (!dragItem || dragItem.tile !== tile) {
                    tile.vx = 0;
                    tile.vy = 0;
                 }
            }
        });

        requestAnimationFrame(updatePhysics);
    }
    
    // -- INPUT HANDLING --

    let dragOffset = {x:0, y:0};

    document.addEventListener('mousedown', handleMouseDown);
    document.addEventListener('mousemove', handleMouseMove);
    document.addEventListener('mouseup', handleMouseUp);

    function handleMouseDown(e) {
        let el = e.target.closest('.tile');
        if (!el) return;

        // Validating data exists
        if (!el.dataset.id) return;

        let id = parseInt(el.dataset.id);
        
        // Find Tile Object (Root or Nested)
        let root = tiles.find(t => t.id === id);
        
        if (root) {
            // Stop physics when grabbed
            root.vx = 0; 
            root.vy = 0;
            startDrag(root, el, e.clientX, e.clientY);
        } else {
             // ... nested logic ...
            // Nested Item Drag
            let parentInfo = findParentOf(id, tiles);
            if (parentInfo) {
                // 1. CAPTURE COORDINATES *BEFORE* MODIFYING DOM
                let rect = el.getBoundingClientRect();
                let canvasRect = canvas.getBoundingClientRect();

                let item = parentInfo.item;
                parentInfo.parent.parts.splice(parentInfo.index, 1);
                
                // Cleanup Parent
                // STRICT MODE: When dragging OUT, do not auto-combine remaining junk.
                simplifyContainer(parentInfo.parent, false);
                
                if (tiles.includes(parentInfo.parent) && parentInfo.parent.parts.length === 0 && parentInfo.parent.type === 'container') {
                    tiles = tiles.filter(t => t !== parentInfo.parent);
                    let parentEl = document.querySelector(`.tile[data-id="${parentInfo.parent.id}"]`);
                    if(parentEl) parentEl.remove();
                } else {
                    let parentEl = document.querySelector(`.tile[data-id="${parentInfo.parent.id}"]`);
                    if (parentEl) updateTileVisuals(parentEl, parentInfo.parent);
                }

                // Promote to Root
                // Use captured rects
                item.x = rect.left - canvasRect.left;
                item.y = rect.top - canvasRect.top;
                tiles.push(item);
                
                let newEl = renderTile(item);
                startDrag(item, newEl, e.clientX, e.clientY);
            }
        }
    }

    function startDrag(tileObj, domEl, mx, my) {
        isDragging = true;
        
        // Calculate offset mouse has inside the tile
        let rect = domEl.getBoundingClientRect();
        let canvasRect = canvas.getBoundingClientRect();
        
        // Important: Coordinate system is relative to Canvas
        let tileX = rect.left - canvasRect.left;
        let tileY = rect.top - canvasRect.top;
        
        dragOffset = {
            x: mx - tileX, // e.g. mouse is 10px in from left
            y: my - tileY
        };

        dragItem = {
            tile: tileObj,
            el: domEl
        };

        domEl.classList.add('dragging');
        domEl.style.zIndex = 1000;
        
        // HIT TEST FEEDBACK INITIAL
        document.querySelectorAll('.hover-target').forEach(el => el.classList.remove('hover-target'));
        
        // Reset Velocity tracking
        lastMouseX = mx;
        lastMouseY = my;
        mouseVX = 0;
        mouseVY = 0;
    }

    function handleMouseMove(e) {
        if (!isDragging || !dragItem) return;
        
        // Calculate Velocity
        mouseVX = e.clientX - lastMouseX;
        mouseVY = e.clientY - lastMouseY;
        lastMouseX = e.clientX;
        lastMouseY = e.clientY;

        // Move Logic
        let canvasRect = canvas.getBoundingClientRect();
        let mouseInsideX = e.clientX - canvasRect.left; 
        let mouseInsideY = e.clientY - canvasRect.top;

        // Apply Offset
        let newX = mouseInsideX - dragOffset.x;
        let newY = mouseInsideY - dragOffset.y;
        
        dragItem.tile.x = newX;
        dragItem.tile.y = newY;
        
        dragItem.el.style.left = newX + 'px';
        dragItem.el.style.top = newY + 'px';
        
        // HIT TEST FEEDBACK
        // Temporarily hide drag item to see what's under
        dragItem.el.style.display = 'none';
        let elBelow = document.elementFromPoint(e.clientX, e.clientY);
        dragItem.el.style.display = '';

        // Clear previous highlights
        document.querySelectorAll('.hover-target').forEach(el => el.classList.remove('hover-target'));

        if (elBelow) {
            let targetTileEl = elBelow.closest('.tile');
            // Don't highlight self or dragging parts (not possible if hidden, but safe check)
            if (targetTileEl && targetTileEl !== dragItem.el) {
                // If it's a sub-item, highlighting it helps user know they will hit IT, not the container
                targetTileEl.classList.add('hover-target');
            }
        }
    }

    function handleMouseUp(e) {
        if (!isDragging || !dragItem) return;

        isDragging = false;
        dragItem.el.classList.remove('dragging');
        dragItem.el.style.zIndex = '';
        document.querySelectorAll('.hover-target').forEach(el => el.classList.remove('hover-target'));

        // Use Mouse Position for Merge Check
        let merged = checkMerge(dragItem.tile, dragItem.el, e.clientX, e.clientY);
        
        if (!merged) {
            // THROW MECHANIC: Apply collected mouse velocity to the tile
            dragItem.tile.vx = mouseVX * 1.5; // Amplify slightly for feel
            dragItem.tile.vy = mouseVY * 1.5;
        }

        dragItem = null;
    }
    
    function spawnTileIfNeeded() {
        if (tiles.length < SPAWN_ROWS * SPAWN_COLS) {
             // Maybe spawn if low? Or just keep random spawning?
             // User likes "Spawn points" idea.
             // We can check if any spawn point is free.
             // spawnTile(1); // Optional: Auto spawn?
             // Game loop usually spawns on merge/move.
             // Since we have no "Turns", maybe just a button or timed?
             // Or auto-replenish if below count?
             if (tiles.length < 3) spawnTile(1);
        }
    }

    // -- RENDER ENGINE --

    function renderTile(tile) {
        // Create full DOM tree driven by data
        // For Root tiles, we position absolute.
        // For children, static.
        
        let el = createTileDOM(tile);
        el.style.left = tile.x + 'px';
        el.style.top = tile.y + 'px';
        
        canvas.appendChild(el);
        return el;
    }

    function createTileDOM(tile) {
        let el = document.createElement('div');
        el.className = 'tile';
        el.dataset.id = tile.id;
        
        if (tile.type === 'pure') {
            el.dataset.val = tile.value;
            el.innerText = tile.value;

            // DYNAMIC COLOR for > 28
            if (tile.value > 28) {
                // Procedural Color
                // Base hue around 10 (Red-Orange from 28).
                // Let's shift hue by -20 degrees for each step
                let step = Math.log2(tile.value / 28);
                let hue = (15 - (step * 25)) % 360; 
                if (hue < 0) hue += 360;
                
                // Saturation high, Lightness around 50-60%
                el.style.backgroundColor = `hsl(${hue}, 85%, 55%)`;
                el.style.color = '#fff';
                el.style.textShadow = '0 1px 2px rgba(0,0,0,0.3)';
                // Optional: Glow for very high numbers
                if(tile.value >= 100) {
                     el.style.boxShadow = `0 0 10px hsl(${hue}, 85%, 55%)`;
                }
            } else {
                // Standard CSS handles it, but ensure we clean up inline sytle if reused
                el.style.backgroundColor = '';
                el.style.color = '';
                el.style.textShadow = '';
                el.style.boxShadow = ''; 
            }

        } else {
            el.classList.add('container');
            tile.parts.forEach(p => {
                let sub = createTileDOM(p);
                // CSS handles positioning (relative) and size now
                el.appendChild(sub);
            });
        }
        return el;
    }

    function updateTileVisuals(el, tile) {
        // Full Re-build of content (safer than diffing for now)
        el.className = 'tile'; // Reset
        el.innerHTML = '';
        el.style.backgroundColor = ''; // clear dynamic color
        el.style.color = '';
        el.style.boxShadow = '';
        
        // Re-apply classes/content
        if (tile.type === 'pure') {
            el.dataset.val = tile.value;
            el.innerText = tile.value;
            
            // DYNAMIC COLOR COPY
             if (tile.value > 28) {
                let step = Math.log2(tile.value / 28);
                let hue = (15 - (step * 25)) % 360; 
                if (hue < 0) hue += 360;
                
                el.style.backgroundColor = `hsl(${hue}, 85%, 55%)`;
                el.style.color = '#fff';
                 el.style.textShadow = '0 1px 2px rgba(0,0,0,0.3)';
                 if(tile.value >= 100) {
                     el.style.boxShadow = `0 0 10px hsl(${hue}, 85%, 55%)`;
                }
            }

        } else {
            el.classList.add('container');
            tile.parts.forEach(p => {
                let sub = createTileDOM(p);
                 // CSS handles positioning (relative) and size now
                el.appendChild(sub);
            });
        }
        el.dataset.id = tile.id;
        el.classList.remove('dragging');
    }

    // -- UI INTERACTIONS --
    // Mouse Tracker for UI Fading
    document.addEventListener('mousemove', (e) => {
        let ui = document.getElementById('overseer-ui');
        if (!ui || ui.style.display === 'none') return;
        
        // Check if mouse is near Top-Right corner (where UI is)
        // UI is approx 300px wide, ~200px+ tall?
        // Let's safe zone: Right 350px, Top 400px.
        
        let inZone = (e.clientX > window.innerWidth - 350) && (e.clientY < 400);
        
        if (inZone) {
            ui.style.opacity = '0.1';
            ui.style.pointerEvents = 'none'; // Ensure clicks pass through when fading
        } else {
            ui.style.opacity = '1';
            ui.style.pointerEvents = 'none'; // Always pure visual? User asked for interaction?
            // User said: "make it very transparent when mouse over so the tiles can be clicked"
            // So we keep it pointer-events: none (it already is via CSS for children, but let's enforce)
            // But visually full opacity when far away.
        }
    });

    // -- AI OVERSEER SYSTEM --
    const Overseer = {
        active: false,
        currentQuest: null,
        level: 1, 
        
        boot: function() {
            this.active = true;
            let ui = document.getElementById('overseer-ui');
            ui.style.display = 'block';
            this.log("Connecting to Neural Net...");
            setTimeout(() => this.log("Connection Established."), 1000);
            setTimeout(() => this.generateQuest(), 2000);
            
            setInterval(() => {
                if(this.currentQuest) this.checkQuest();
            }, 1000);
        },

        log: function(msg) {
            let el = document.getElementById('overseer-log');
            el.innerHTML = `> ${msg}<span class="typing-cursor"></span>`;
        },

        generateQuest: function() {
            this.level++;
            
            // Generate a Target Structure (Molecule)
            // 30% Chance Pure High Value
            // 70% Chance Complex Container
            let isContainer = Math.random() > 0.3;
            let targetTile;
            
            if (!isContainer) {
                let standards = [14, 28, 56, 112, 224];
                let idx = Math.min(Math.floor(this.level / 3), standards.length - 1);
                targetTile = new TileData('pure', standards[idx], 0, 0);
                
                this.currentQuest = {
                    type: 'find_structure',
                    target: targetTile,
                    desc: `Synthesize Isotope [${targetTile.value}]`
                };
            } else {
                // Generate Random Container Tree
                // Depth 1 or 2 based on level
                let depth = this.level > 5 ? 2 : 1;
                targetTile = this.generateRandomStructure(depth);
                
                this.currentQuest = {
                    type: 'find_structure',
                    target: targetTile,
                    desc: `Assemble Specific Molecular Structure`
                };
            }
            
            // UI Update
            document.getElementById('overseer-quest').innerHTML = `MISSION: ${this.currentQuest.desc}`;
            this.log(`New Blueprint Downloaded. Lv ${this.level}`);
            
            // Render Preview
            let previewEl = document.getElementById('overseer-preview');
            previewEl.innerHTML = '';
            // We use createTileDOM but need to handle size
            let visual = createTileDOM(targetTile);
            previewEl.appendChild(visual);
        },
        
        generateRandomStructure: function(depth) {
            // SAFE GENERATION LOOP
            // We must produce a container that does NOT auto-merge.
            // Rules:
            // - No 3x [1]
            // - No [3] + [1] (Wait, 3+1=4? Yes. Avoid specific pairs?)
            // - No [4] + [3]
            // - No 2x [Same Value >= 7]
            
            let valid = false;
            let parts = [];
            let attempts = 0;
            
            while(!valid && attempts < 20) {
                valid = true;
                parts = [];
                let count = 2 + Math.floor(Math.random() * 2);
                let values = []; // Pure values in this container
                
                for(let i=0; i<count; i++) {
                    if (depth > 0 && Math.random() > 0.7) {
                        parts.push(this.generateRandomStructure(depth - 1));
                    } else {
                        let vals = [1, 4, 7];
                        if (this.level > 3) vals.push(14);
                        if (this.level > 1 && Math.random() > 0.5) vals.push(3); // Add 3s
                        
                        let v = vals[Math.floor(Math.random() * vals.length)];
                        parts.push(new TileData('pure', v, 0,0));
                        values.push(v);
                    }
                }
                
                // VALIDATE THIS COMBINATION
                let counts = {};
                values.forEach(v => counts[v] = (counts[v] || 0) + 1);
                
                // Check Rules
                if ((counts[1] || 0) >= 3) valid = false;
                if ((counts[3] || 0) >= 1 && (counts[1] || 0) >= 1) valid = false; // 3+1 -> 4
                if ((counts[4] || 0) >= 1 && (counts[3] || 0) >= 1) valid = false; // 4+3 -> 7
                
                // Check Doubles >= 7
                for (let v in counts) {
                    if (parseInt(v) >= 7 && counts[v] >= 2) valid = false;
                }
                
                attempts++;
            }
            
            // If failed to find specific valid, fallback to simple valid 
            if (!valid) {
                return new TileData('container', [
                    new TileData('pure', 4,0,0), 
                    new TileData('pure', 1,0,0) // Safe
                ], 0, 0);
            }

            return new TileData('container', parts, 0, 0);
        },

        checkQuest: function() {
            if (!this.currentQuest) return;
            
            // Scan all root tiles
            // We need to check if ANY tile matches the structure
            let found = tiles.some(t => this.compareStructure(t, this.currentQuest.target));

            if (found) {
                this.completeQuest();
            }
        },
        
        compareStructure: function(tile, target) {
            if (tile.type !== target.type) return false;
            if (tile.type === 'pure') return tile.value === target.value;
            
            // Container matching
            if (tile.parts.length !== target.parts.length) return false;
            
            // Order doesn't matter for "Soup", but for "Structure" it might?
            // "Exact Container" usually implies content match.
            // Let's sort both by value/type signature to compare loosely ordered (Bag equality)
            // Or strict? User said "Exact container".
            // Let's go with Bag Equality (must contain same items, order irrelevant)
            
            let tileItems = [...tile.parts];
            let targetItems = [...target.parts];
            
            // For each target item, find a match in tileItems and remove it
            for (let tItem of targetItems) {
                let matchIdx = tileItems.findIndex(p => this.compareStructure(p, tItem));
                if (matchIdx === -1) return false; // Missing component
                tileItems.splice(matchIdx, 1); // Consumed
            }
            
            return true;
        },

        completeQuest: function() {
            this.log("STRUCTURE MATCH CONFIRMED.");
            document.getElementById('overseer-quest').innerHTML = `<span style="color:#0f0">SUCCESS</span>`;
            
            let previewEl = document.getElementById('overseer-preview');
            previewEl.innerHTML = '<div style="color:#0f0; font-size:30px;"></div>';

            spawnExplosion(window.innerWidth/2, window.innerHeight/2, '#0f0');
            spawnTile(7); // Reward
            
            this.currentQuest = null;
            setTimeout(() => this.generateQuest(), 3000); 
        }
    };

    // Boot after short delay
    setTimeout(() => Overseer.boot(), 1000);

    // Initial Game Boot
    init();

    // Spawn controls
    document.addEventListener('keydown', (e) => {
        if (e.code === 'Space') spawnTile(1);
    });

    // -- SCREEN SHAKE --
    function triggerScreenShake(intensity = 1) {
        let body = document.body;
        // Reset animation
        body.style.animation = 'none';
        body.offsetHeight; /* trigger reflow */
        body.style.animation = `shake 0.5s cubic-bezier(.36,.07,.19,.97) both`;
    }

</script>
</body>
</html>